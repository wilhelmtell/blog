May 5, 2012

 Resource Acquisition Is Initialization

When we manually acquire a resource--dynamic memory, a file handle, a network
connection--we take the responsibility of releasing the resource at the correct
moment; be it any return point, via an error or otherwise, or at the end of the
resource's scope. The more complex the code within the resource lifetime,
whether in our code or in any function our code calls (and so on recursively),
the more difficult it is to make sure the resource releases correctly and
efficiently.

This is not just about avoiding plain-vanilla leaks: if done manually the code
repeats itself, almost copy-pasted semantically speaking. And it's not just
about eliminating code duplication but also about accounting for errors. We
know errors happen (albeit not precisely when). We have to anticipate that and
make sure our resources clean up regardless of how we leave a function.

A garbage collector only offers a solution for memory leaks, and that solution
is non-deterministic. Instead we take advantage of a useful set of guarantees
C++ has with regard to automatic object lifetime:

 1  An object does not exist, as if never existed to begin with, unless and
    until its constructor successfully completes its business.
 2  Objects destruct at the end of their scope in the reverse order of that in
    which they instantiated.

In the RAII idiom we wrap every resource in a class. We acquire the resource in
the class constructor and release the resource in the class destructor. We then
know that if the resource successfully acquires it will clean up exactly when
it is no longer needed--when the scope of the object ends or when an exception
triggers.

 { std::ofstream undo_file("undo");
 }  // file closes here. no open(), no close()!

 { network net("http://example.com/");
     comm(net);  // if an exception triggers, net automatically cleans up here
 }  // otherwise network session gracefully ends here.

To implement the RAII idiom correctly for a resource the rule of three reminds
us that because we have a destructor we must also think about copy semantics
for the class. In the simplest of cases or when we want to defer implementing
correct copy functions until we need copying we delete the copy constructor and
copy assignment so the resource is not copiable.


April 20, 2012

 auto const

auto const means T const. If T is a pointer of type P then auto const means
auto P * const. If you want to qualify the pointee const then place the const
keyword before an asterisk:

 T* get_pointer();

 void play()
 {
     auto const p0(get_pointer());         // T       * const
     auto * const p1(get_pointer());       // T       * const
     auto const * p2(get_pointer());       // T const *
     auto const * const p3(get_pointer()); // T const * const
 }

This is similar to good old template specializations:

 template<typename T>
 struct block { };

 template<typename T>
 struct block<T*> { };

 template<typename T>
 struct block<T * const> { };

 template<typename T>
 struct block<T const *> { };

 template<typename T>
 struct block<T const * const> { };


April 20, 2012

 A Note on the main Function

Section 3.6.1 of the C++11 standard states that the main function may take
either of these two forms:

 int main() { /* ... */ }

and

 int main(int argc, char* argv[]) { /* ... */ }

If an implementation must allow main to take an argument of type char*[] then a
more const-restricted signature is valid as well:

 int main(int argc, char const * argv[]) { /* ... */ }

And even

 int main(int argc, char const * const argv[]) { /* ... */ }

And if you can, why won't you?
